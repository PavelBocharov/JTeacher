{
  "type": "/sql",
  "description": "Тест по PostgreSQL для разработчиков",
  "version": "202510311418",
  "questions": [
    {
      "question": "Что такое CTE (Common Table Expressions) и для чего они используются?",
      "options": [
        "A: Временные таблицы, существующие только во время сессии",
        "B: Именованные подзапросы, улучшающие читаемость сложных запросов",
        "C: Глобальные временные таблицы для всех пользователей",
        "D: Системные таблицы для метаданных БД"
      ],
      "correct_answer": "B",
      "detailed_answer": "CTE (Common Table Expressions) - это именованные временные результирующие наборы, которые существуют только во время выполнения запроса.\n\n*Синтаксис:*\n```sql\nWITH cte_name AS (\n    SELECT column1, column2\n    FROM table_name\n    WHERE condition\n)\nSELECT * FROM cte_name;\n```\n\n*Преимущества:*\n• Улучшают читаемость сложных запросов\n• Позволяют рекурсивные запросы\n• Могут использоваться многократно в одном запросе\n\n*Пример рекурсивного CTE:*\n```sql\nWITH RECURSIVE numbers AS (\n    SELECT 1 as n\n    UNION ALL\n    SELECT n + 1 FROM numbers WHERE n < 10\n)\nSELECT * FROM numbers;\n```"
    },
    {
      "question": "Какая разница между INNER JOIN и LEFT JOIN?",
      "options": [
        "A: INNER JOIN возвращает все строки, LEFT JOIN только совпадающие",
        "B: INNER JOIN возвращает совпадающие строки, LEFT JOIN все строки левой таблицы",
        "C: Оба возвращают одинаковый результат, но разная производительность",
        "D: INNER JOIN для числовых полей, LEFT JOIN для текстовых"
      ],
      "correct_answer": "B",
      "detailed_answer": "*INNER JOIN vs LEFT JOIN:*\n\n*INNER JOIN* - возвращает только строки, где есть совпадение в обеих таблицах\n*LEFT JOIN* - возвращает все строки из левой таблицы и совпадающие из правой\n\n*Пример:*\n```sql\n-- INNER JOIN (только сотрудники с отделами)\nSELECT e.name, d.department_name\nFROM employees e\nINNER JOIN departments d ON e.department_id = d.id;\n\n-- LEFT JOIN (все сотрудники, даже без отделов)\nSELECT e.name, d.department_name\nFROM employees e\nLEFT JOIN departments d ON e.department_id = d.id;\n```\n\n*Визуализация:*\nINNER JOIN: ∩ (пересечение)\nLEFT JOIN: все из левой + совпадения из правой"
    },
    {
      "question": "Что такое оконные функции (Window Functions) в PostgreSQL?",
      "options": [
        "A: Функции для работы с окнами приложения",
        "B: Функции, выполняемые над набором строк без группировки",
        "C: Функции для создания новых окон в БД",
        "D: Системные функции управления окнами сессий"
      ],
      "correct_answer": "B",
      "detailed_answer": "Оконные функции выполняют вычисления над набором строк, связанных с текущей строкой, без группировки результатов.\n\n*Синтаксис:*\n```sql\nfunction_name() OVER (\n    PARTITION BY column\n    ORDER BY column\n    frame_clause\n)\n```\n\n*Популярные оконные функции:*\n• `ROW_NUMBER()` - номер строки в партиции\n• `RANK()` - ранг с пропусками\n• `DENSE_RANK()` - ранг без пропусков\n• `LAG()/LEAD()` - доступ к предыдущей/следующей строке\n\n*Пример:*\n```sql\nSELECT \n    name,\n    department,\n    salary,\n    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank_in_dept\nFROM employees;\n```"
    },
    {
      "question": "Для чего используется команда EXPLAIN в PostgreSQL?",
      "options": [
        "A: Для объяснения структуры таблиц",
        "B: Для показа плана выполнения запроса",
        "C: Для описания функций БД",
        "D: Для объяснения синтаксиса SQL"
      ],
      "correct_answer": "B",
      "detailed_answer": "EXPLAIN показывает план выполнения запроса, что помогает в оптимизации.\n\n*Базовое использование:*\n```sql\nEXPLAIN SELECT * FROM users WHERE age > 30;\n```\n\n*С анализом стоимости:*\n```sql\nEXPLAIN ANALYZE SELECT * FROM users WHERE age > 30;\n```\n\n*Ключевые элементы плана:*\n• *Seq Scan* - последовательное сканирование\n• *Index Scan* - сканирование по индексу\n• *Nested Loop* - вложенные циклы\n• *Hash Join* - соединение хешированием\n\n*Пример оптимизации:*\n```sql\n-- До индекса\nEXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';\n\n-- Создаем индекс\nCREATE INDEX idx_users_email ON users(email);\n\n-- После индекса\nEXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';\n```"
    },
    {
      "question": "Что такое транзакции и каковы их свойства (ACID)?",
      "options": [
        "A: Группа операций с свойствами Atomicity, Consistency, Isolation, Durability",
        "B: Способ создания резервных копий БД",
        "C: Метод индексации таблиц для ускорения запросов",
        "D: Процедура репликации данных между серверами"
      ],
      "correct_answer": "A",
      "detailed_answer": "Транзакции - это группа операций, выполняемых как единое целое с гарантиями ACID.\n\n*Свойства ACID:*\n\n*Atomicity (Атомарность)* - все операции выполняются или ни одна\n```sql\nBEGIN;\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nUPDATE accounts SET balance = balance + 100 WHERE id = 2;\nCOMMIT; -- или ROLLBACK при ошибке\n```\n\n*Consistency (Согласованность)* - БД переходит из одного валидного состояния в другое\n\n*Isolation (Изолированность)* - транзакции не мешают друг другу\n*Уровни изоляции в PostgreSQL:*\n- Read Committed (по умолчанию)\n- Repeatable Read\n- Serializable\n\n*Durability (Долговечность)* - подтвержденные изменения сохраняются после сбоев"
    },
    {
      "question": "Какая разница между VARCHAR и TEXT в PostgreSQL?",
      "options": [
        "A: VARCHAR имеет ограничение длины, TEXT - нет",
        "B: TEXT только для больших текстов, VARCHAR для маленьких",
        "C: VARCHAR быстрее для поиска, TEXT для хранения",
        "D: Никакой разницы, оба типа идентичны"
      ],
      "correct_answer": "A",
      "detailed_answer": "Разница между VARCHAR и TEXT в PostgreSQL:\n\n*VARCHAR(n)* - строка переменной длины с ограничением\n```sql\nCREATE TABLE users (\n    name VARCHAR(50)  -- максимум 50 символов\n);\n```\n\n*TEXT* - строка переменной длины без ограничения\n```sql\nCREATE TABLE posts (\n    content TEXT  -- без ограничения длины\n);\n```\n\n*Рекомендации:*\n• Используйте TEXT для произвольных строк\n• VARCHAR когда нужны строгие ограничения\n• Производительность практически идентична\n\n*Пример сравнения:*\n```sql\n-- VARCHAR выдаст ошибку при превышении\nINSERT INTO users (name) VALUES ('Очень длинное имя которое превышает лимит в 50 символов');\n\n-- TEXT примет любую длину\nINSERT INTO posts (content) VALUES ('Очень длинный текст...');\n```"
    },
    {
      "question": "Что такое индексы в PostgreSQL и какие типы индексов вы знаете?",
      "options": [
        "A: Структуры для ускорения поиска, типы: B-tree, Hash, GiST, GIN",
        "B: Резервные копии таблиц для восстановления",
        "C: Методы шифрования данных в таблицах",
        "D: Системные таблицы для хранения метаданных"
      ],
      "correct_answer": "A",
      "detailed_answer": "Индексы - структуры данных для ускорения операций поиска в таблицах.\n\n*Основные типы индексов:*\n\n*B-tree* - стандартный индекс для сравнений и сортировок\n```sql\nCREATE INDEX idx_users_email ON users(email);\n```\n\n*Hash* - для точных сравнений (=)\n```sql\nCREATE INDEX idx_users_id_hash ON users USING HASH(id);\n```\n\n*GiST* - для сложных данных (геоданные, полнотекстовый поиск)\n```sql\nCREATE INDEX idx_posts_content_gist ON posts USING GIST(to_tsvector('english', content));\n```\n\n*GIN* - для составных значений (массивы, JSON)\n```sql\nCREATE INDEX idx_products_tags_gin ON products USING GIN(tags);\n```\n\n*BRIN* - для очень больших таблиц с естественной сортировкой\n```sql\nCREATE INDEX idx_sensor_data_brin ON sensor_data USING BRIN(timestamp);\n```"
    },
    {
      "question": "В чем разница между реляционными и нереляционными базами данных?",
      "options": [
        "A: Реляционные - таблицы, SQL, строгая схема; NoSQL - документы/графы/ключ-значение, гибкая схема",
        "B: Оба типа одинаковы по структуре",
        "C: NoSQL использует только таблицы",
        "D: Реляционные БД не имеют схемы"
      ],
      "correct_answer": "A",
      "detailed_answer": "Реляционные и нереляционные базы данных (NoSQL) - это два основных типа баз данных, используемых в разработке программного обеспечения. Основные отличия между ними заключаются в способе организации и хранения данных.\n\n`Реляционные базы данных (RDBMS) являются структурированными базами данных, которые хранят данные в таблицах с предопределенными полями, каждое поле имеет определенный тип данных`. Каждая строка таблицы представляет отдельную запись, а столбцы таблицы представляют собой атрибуты записи. Реляционные базы данных используют язык SQL (Structured Query Language) для работы с данными. Они обладают строгой схемой данных, что означает, что они требуют заранее определенной структуры таблиц и соответствующих связей между ними.\n\n`Нереляционные базы данных (NoSQL) - это базы данных, которые не используют табличную структуру для хранения данных, а вместо этого используют другие форматы хранения, такие как документы, графы или ключ-значение`. Нереляционные базы данных могут хранить и обрабатывать большие объемы неструктурированных данных, таких как данные социальных сетей, системы рекомендаций и IoT (интернет вещей). Они обладают гибкой схемой данных, что означает, что они не требуют заранее определенной структуры таблиц и связей между ними. Вместо этого данные хранятся в документах или других форматах без установленной структуры.\n\nТаким образом, основное отличие между реляционными и нереляционными базами данных заключается в способе организации данных - реляционные базы данных используют табличную структуру с заранее определенными полями, а нереляционные базы данных хранят данные в других форматах без установленной структуры."
    },
    {
      "question": "Как сохраняются соотношения one-to-one, one-to-many и many-to-many в виде таблиц?",
      "options": [
        "A: One-to-one - внешний ключ с unique, one-to-many - внешний ключ, many-to-many - связующая таблица",
        "B: Все соотношения хранятся в одной таблице",
        "C: One-to-many через массивы, many-to-many через JSON",
        "D: Все соотношения требуют связующих таблиц"
      ],
      "correct_answer": "A",
      "detailed_answer": "Соотношения между таблицами в реляционных базах данных могут быть выражены как one-to-one (один-к-одному), one-to-many (один-ко-многим) или many-to-many (многие-ко-многим).\n\nДля хранения соотношения один-к-одному между двумя сущностями можно использовать одну из двух стратегий:\n\n+ В первой стратегии каждая таблица содержит ссылку на другую таблицу по первичному ключу. Таким образом, каждая строка в одной таблице имеет только одну связанную строку в другой таблице.\n\n+ Во второй стратегии одна из таблиц содержит первичный ключ, который также является внешним ключом для связанной таблицы. Таким образом, каждая строка в одной таблице связана с одной строкой в другой таблице, а каждая строка во второй таблице может быть связана с несколькими строками в первой таблице.\n\nДля хранения соотношения один-ко-многим между двумя сущностями используется вторая стратегия, упомянутая выше.\n\nДля хранения соотношения многие-ко-многим между двумя сущностями требуется создание дополнительной таблицы-связки, которая содержит первичные ключи обеих таблиц. Таким образом, каждая строка в таблице-связке связывает одну строку из первой таблицы с одной строкой из второй таблицы, а каждая из этих таблиц может быть связана с несколькими строками в другой таблице.\n\nНапример, предположим, что есть две таблицы - \"Пользователи\" и \"Заказы\". Каждый пользователь может иметь несколько заказов, а каждый заказ может быть связан только с одним пользователем. В этом случае мы можем использовать вторую стратегию для хранения соотношения один-ко-многим между таблицами \"Пользователи\" и \"Заказы\". Для хранения соотношения многие-ко-многим, нам необходимо создать дополнительную таблицу-связку \"ПользователиЗаказы\", которая будет содержать первичные ключи обеих таблиц."
    },
    {
      "question": "Что такое нормализация базы данных? Приведите примеры реального проекта.",
      "options": [
        "A: Процесс устранения избыточности данных через разделение таблиц и установление связей",
        "B: Увеличение размера базы данных для улучшения производительности",
        "C: Объединение всех данных в одну таблицу",
        "D: Удаление всех связей между таблицами"
      ],
      "correct_answer": "A",
      "detailed_answer": "Нормализация базы данных - это процесс проектирования базы данных с целью устранения избыточных, повторяющихся или несогласованных данных. Цель нормализации базы данных состоит в том, чтобы минимизировать размер базы данных и обеспечить целостность данных, предотвращая дублирование информации.\n\nСуществует несколько стадий нормализации, которые описывают отношение между таблицами и атрибутами, и каждый уровень нормализации имеет свои правила, которые определяют, какие типы данных должны быть вынесены в отдельные таблицы и как они должны быть связаны друг с другом.\n\n**Основные нормальные формы:**\n\n+ **1NF (Первая нормальная форма)**: \n  - Устранение повторяющихся групп\n  - Все атрибуты атомарны (неделимы)\n  - Каждая запись уникальна\n\n+ **2NF (Вторая нормальная форма)**:\n  - Должна удовлетворять 1NF\n  - Все неключевые атрибуты полностью зависят от первичного ключа\n  - Устранение частичных зависимостей\n\n+ **3NF (Третья нормальная форма)**:\n  - Должна удовлетворять 2NF  \n  - Все неключевые атрибуты зависят только от первичного ключа\n  - Устранение транзитивных зависимостей\n\n+ **BCNF (Форма Бойса-Кодда)**:\n  - Усиленная 3NF\n  - Каждая детерминанта является потенциальным ключом\n  - Устранение всех нетривиальных зависимостей\n\n+ **4NF (Четвертая нормальная форма)**:\n  - Должна удовлетворять BCNF\n  - Устранение многозначных зависимостей\n  - Нет нетривиальных многозначных зависимостей\n\n+ **5NF (Пятая нормальная форма)**:\n  - Должна удовлетворять 4NF\n  - Устранение зависимостей соединения\n  - Таблица не может быть разделена на меньшие таблицы без потери информации\n\n+ **6NF (Шестая нормальная форма)**:\n  - Должна удовлетворять 5NF\n  - Каждая связь содержит только один факт\n  - Используется в темпоральных базах данных\n\nПримеры реального проекта включают в себя любую базу данных, используемую в приложениях, таких как системы управления контентом (CMS), системы управления заказами (OMS), системы управления кастомер-реляшенз (CRM), системы управления отношениями с поставщиками (SRM) и другие подобные системы.\n\nНапример, пусть есть база данных для онлайн-магазина, которая включает в себя таблицы \"Клиенты\", \"Заказы\", \"Товары\" и \"Отзывы\". В этом случае мы можем применить следующие принципы нормализации:\n\n+ `Первый уровень нормализации`: каждая таблица должна иметь уникальный идентификатор, то есть первичный ключ. В таблице \"Клиенты\", например, первичным ключом может быть ID клиента, а в таблице \"Заказы\" - номер заказа.\n+ `Второй уровень нормализации`: выделение зависимых данных в отдельную таблицу. Например, для таблицы \"Заказы\" мы можем выделить отдельную таблицу \"Детали заказов\", которая будет содержать информацию о количестве и цене каждого заказанного товара.\n+ `Третий уровень нормализации`: выделение повторяющихся данных в отдельную таблицу. Например, если у нас есть несколько клиентов с одним и тем же адресом доставки, мы можем выделить отдельную таблицу \"Адреса доставки\", которая будет содержать информацию об адресах доставки и связываться с таблицей \"Клиенты\".\n\nОбычно в реальных проектах базы данных проходят несколько стадий нормализации, чтобы гарантировать эффективность, точность и безопасность хранения информации."
    },
    {
      "question": "Какие виды индексов в БД?",
      "options": [
        "A: B-Tree, Bitmap, Hash, Full-text, Composite, Spatial",
        "B: Только B-Tree и Hash",
        "C: Только числовые и строковые индексы",
        "D: Все индексы одинаковые"
      ],
      "correct_answer": "A",
      "detailed_answer": "`Индекс в базе данных (БД)` - это структура данных, которая ускоряет поиск и доступ к данным в таблицах БД. Существует несколько видов индексов, используемых в БД:\n\n+ `Индексы B-Tree`: Это самый распространенный тип индекса в БД. Он используется для быстрого поиска данных по ключу. Примерами таких индексов являются индексы UNIQUE и PRIMARY KEY.\n+ `Bitmap-индексы`: Эти индексы используются для быстрого поиска в больших таблицах с низкой выборкой. Они работают путем создания битовых карт, которые указывают на значения строки, соответствующие определенному условию.\n+ `Индексы хэш-таблиц`: Эти индексы используются для поиска данных по точному значению ключа. Они работают путем хэширования значений ключа и сохранением ссылок на соответствующие данные в БД.\n+ `Индексы полнотекстового поиска`: Эти индексы используются для поиска текстовых данных в БД. Они обрабатывают запросы, содержащие слова или фразы, и возвращают результаты в порядке их релевантности.\n+ `Составные индексы`: Эти индексы используются для оптимизации поиска, состоящего из нескольких полей. Они работают путем объединения значений нескольких полей в одно значение и создания индекса на основе этого значения.\n+ `Индексы пространственных данных`: Эти индексы используются для работы с данными географического типа или с картами. Они позволяют быстро и эффективно выполнять запросы, связанные с геоспатиальными данными.\n\nВыбор определенного типа индекса зависит от специфики БД, ее размера и доступных ресурсов."
    }
  ]
}